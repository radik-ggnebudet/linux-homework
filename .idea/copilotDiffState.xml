<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FS-10/copy.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FS-10/copy.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;cerrno&gt;&#10;#include &lt;cstring&gt;&#10;&#10;using namespace std;&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc != 3) {&#10;        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;source-file&gt; &lt;destination-file&gt;&quot; &lt;&lt; endl;&#10;        return 1;&#10;    }&#10;&#10;    const char* source_path = argv[1];&#10;    const char* dest_path = argv[2];&#10;&#10;    int src_fd = open(source_path, O_RDONLY);&#10;    if (src_fd == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot open source file&quot; &lt;&lt; endl;&#10;        return 1;&#10;    }&#10;&#10;    struct stat src_stat;&#10;    if (fstat(src_fd, &amp;src_stat) == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot stat source file&quot; &lt;&lt; endl;&#10;        close(src_fd);&#10;        return 1;&#10;    }&#10;&#10;    int dest_fd = open(dest_path, O_WRONLY | O_CREAT | O_TRUNC, src_stat.st_mode);&#10;    if (dest_fd == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot open destination file&quot; &lt;&lt; endl;&#10;        close(src_fd);&#10;        return 1;&#10;    }&#10;&#10;    const size_t BUFFER_SIZE = 4096;&#10;    char buffer[BUFFER_SIZE];&#10;    off_t total_bytes = 0;&#10;    off_t data_bytes = 0;&#10;    off_t hole_bytes = 0;&#10;&#10;    off_t pos = 0;&#10;    off_t file_size = src_stat.st_size;&#10;&#10;    while (pos &lt; file_size) {&#10;        off_t data_start = lseek(src_fd, pos, SEEK_DATA);&#10;&#10;        if (data_start == -1) {&#10;            if (errno == ENXIO) {&#10;                hole_bytes += file_size - pos;&#10;                if (lseek(dest_fd, file_size - 1, SEEK_SET) != -1) {&#10;                    write(dest_fd, &quot;&quot;, 1);&#10;                }&#10;                break;&#10;            } else {&#10;                cerr &lt;&lt; &quot;Error: lseek SEEK_DATA failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;        }&#10;&#10;        if (data_start &gt; pos) {&#10;            hole_bytes += data_start - pos;&#10;            if (lseek(dest_fd, data_start, SEEK_SET) == -1) {&#10;                cerr &lt;&lt; &quot;Error: Cannot seek in destination&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;        }&#10;&#10;        off_t hole_start = lseek(src_fd, data_start, SEEK_HOLE);&#10;        if (hole_start == -1) {&#10;            cerr &lt;&lt; &quot;Error: lseek SEEK_HOLE failed&quot; &lt;&lt; endl;&#10;            close(src_fd);&#10;            close(dest_fd);&#10;            return 1;&#10;        }&#10;&#10;        off_t data_len = hole_start - data_start;&#10;&#10;        if (lseek(src_fd, data_start, SEEK_SET) == -1) {&#10;            cerr &lt;&lt; &quot;Error: Cannot seek to data start&quot; &lt;&lt; endl;&#10;            close(src_fd);&#10;            close(dest_fd);&#10;            return 1;&#10;        }&#10;&#10;        off_t bytes_to_copy = data_len;&#10;        while (bytes_to_copy &gt; 0) {&#10;            ssize_t to_read = (bytes_to_copy &gt; BUFFER_SIZE) ? BUFFER_SIZE : bytes_to_copy;&#10;            ssize_t bytes_read = read(src_fd, buffer, to_read);&#10;&#10;            if (bytes_read == -1) {&#10;                cerr &lt;&lt; &quot;Error: Read failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;&#10;            if (bytes_read == 0) {&#10;                break;&#10;            }&#10;&#10;            ssize_t bytes_written = write(dest_fd, buffer, bytes_read);&#10;            if (bytes_written == -1) {&#10;                cerr &lt;&lt; &quot;Error: Write failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;&#10;            data_bytes += bytes_written;&#10;            bytes_to_copy -= bytes_read;&#10;        }&#10;&#10;        pos = hole_start;&#10;    }&#10;&#10;    total_bytes = data_bytes + hole_bytes;&#10;&#10;    close(src_fd);&#10;    close(dest_fd);&#10;&#10;    cout &lt;&lt; &quot;Successfully copied &quot; &lt;&lt; total_bytes &lt;&lt; &quot; bytes (data: &quot;&#10;         &lt;&lt; data_bytes &lt;&lt; &quot;, hole: &quot; &lt;&lt; hole_bytes &lt;&lt; &quot;).&quot; &lt;&lt; endl;&#10;&#10;    return 0;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#include &lt;iostream&gt;&#10;#include &lt;fcntl.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;cerrno&gt;&#10;#include &lt;cstring&gt;&#10;&#10;using namespace std;&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc != 3) {&#10;        cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;source-file&gt; &lt;destination-file&gt;&quot; &lt;&lt; endl;&#10;        return 1;&#10;    }&#10;&#10;    const char* source_path = argv[1];&#10;    const char* dest_path = argv[2];&#10;&#10;    int src_fd = open(source_path, O_RDONLY);&#10;    if (src_fd == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot open source file&quot; &lt;&lt; endl;&#10;        return 1;&#10;    }&#10;&#10;    struct stat src_stat;&#10;    if (fstat(src_fd, &amp;src_stat) == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot stat source file&quot; &lt;&lt; endl;&#10;        close(src_fd);&#10;        return 1;&#10;    }&#10;&#10;    int dest_fd = open(dest_path, O_WRONLY | O_CREAT | O_TRUNC, src_stat.st_mode);&#10;    if (dest_fd == -1) {&#10;        cerr &lt;&lt; &quot;Error: Cannot open destination file&quot; &lt;&lt; endl;&#10;        close(src_fd);&#10;        return 1;&#10;    }&#10;&#10;    const size_t BUFFER_SIZE = 4096;&#10;    char buffer[BUFFER_SIZE];&#10;    off_t total_bytes = 0;&#10;    off_t data_bytes = 0;&#10;    off_t hole_bytes = 0;&#10;&#10;    off_t pos = 0;&#10;    off_t file_size = src_stat.st_size;&#10;&#10;    while (pos &lt; file_size) {&#10;        off_t data_start = lseek(src_fd, pos, SEEK_DATA);&#10;&#10;        if (data_start == -1) {&#10;            if (errno == ENXIO) {&#10;                hole_bytes += file_size - pos;&#10;                if (ftruncate(dest_fd, file_size) == -1) {&#10;                    cerr &lt;&lt; &quot;Error: Cannot truncate destination file&quot; &lt;&lt; endl;&#10;                    close(src_fd);&#10;                    close(dest_fd);&#10;                    return 1;&#10;                }&#10;                break;&#10;            } else {&#10;                cerr &lt;&lt; &quot;Error: lseek SEEK_DATA failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;        }&#10;&#10;        if (data_start &gt; pos) {&#10;            hole_bytes += data_start - pos;&#10;            if (lseek(dest_fd, data_start, SEEK_SET) == -1) {&#10;                cerr &lt;&lt; &quot;Error: Cannot seek in destination&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;        }&#10;&#10;        off_t hole_start = lseek(src_fd, data_start, SEEK_HOLE);&#10;        if (hole_start == -1) {&#10;            cerr &lt;&lt; &quot;Error: lseek SEEK_HOLE failed&quot; &lt;&lt; endl;&#10;            close(src_fd);&#10;            close(dest_fd);&#10;            return 1;&#10;        }&#10;&#10;        off_t data_len = hole_start - data_start;&#10;&#10;        if (lseek(src_fd, data_start, SEEK_SET) == -1) {&#10;            cerr &lt;&lt; &quot;Error: Cannot seek to data start&quot; &lt;&lt; endl;&#10;            close(src_fd);&#10;            close(dest_fd);&#10;            return 1;&#10;        }&#10;&#10;        off_t bytes_to_copy = data_len;&#10;        while (bytes_to_copy &gt; 0) {&#10;            ssize_t to_read = (bytes_to_copy &gt; BUFFER_SIZE) ? BUFFER_SIZE : bytes_to_copy;&#10;            ssize_t bytes_read = read(src_fd, buffer, to_read);&#10;&#10;            if (bytes_read == -1) {&#10;                cerr &lt;&lt; &quot;Error: Read failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;&#10;            if (bytes_read == 0) {&#10;                break;&#10;            }&#10;&#10;            ssize_t bytes_written = write(dest_fd, buffer, bytes_read);&#10;            if (bytes_written == -1) {&#10;                cerr &lt;&lt; &quot;Error: Write failed&quot; &lt;&lt; endl;&#10;                close(src_fd);&#10;                close(dest_fd);&#10;                return 1;&#10;            }&#10;&#10;            data_bytes += bytes_written;&#10;            bytes_to_copy -= bytes_read;&#10;        }&#10;&#10;        pos = hole_start;&#10;    }&#10;&#10;    total_bytes = data_bytes + hole_bytes;&#10;&#10;    close(src_fd);&#10;    close(dest_fd);&#10;&#10;    cout &lt;&lt; &quot;Successfully copied &quot; &lt;&lt; total_bytes &lt;&lt; &quot; bytes (data: &quot;&#10;         &lt;&lt; data_bytes &lt;&lt; &quot;, hole: &quot; &lt;&lt; hole_bytes &lt;&lt; &quot;).&quot; &lt;&lt; endl;&#10;&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>